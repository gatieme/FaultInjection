#! /bin/sh

#################### set your defaults here ##############
#FLAVOR= # flavor of UNIX: if not determined by script: SysV or BSD
FULL_SUITE="dhry2reg double syscall pipe context1 spawn execl \
	fstime fsbuffer fsdisk shell short int long float arithoh C dc hanoi"
###############################################################################
#  UnixBench - Release 4, based on:
#  The BYTE UNIX Benchmarks - Release 3
#          Module: Run   SID: 3.11 5/15/91 19:30:14
# Original Byte benchmarks written by:
#	Ben Smith,        	Tom Yager at BYTE Magazine
#	ben@bytepb.byte.com   	tyager@bytepb.byte.com
# BIX:  bensmith          	tyager
#
###############################################################################
#  Modification Log:
# $Header: run,v 5.2 88/01/12 06:23:43 kenj Exp $
#     Ken McDonell, Computer Science, Monash University
#     August 1, 1983
# 3/89 - Ben Smith - BYTE: globalized many variables, modernized syntax
# 5/89 - commented and modernized. Removed workload items till they
#        have been modernized. Added database server test.
# 11/14/89 - Made modifications to reflect new version of fstime
#        and elimination of mem tests.
# 10/22/90 - Many tests have been flipped so that they run for
#        a specified length of time and loops are counted.
#  4/3/91 - Cleaned up and debugged several test parameters - Ben
#  4/9/91 - Added structure for creating index and determing flavor of UNIX
#  4/26/91 - Made changes and corrections suggested by Tin Le of Sony
#  5/15/91 - Removed db from distribution
#  12/95   - Massive changes for portability, speed, and more meaningful index
#            David.Niemi@mail.li.org
#  1997.06.20 - Fixed overflow condition in fstime.c on fast machines.
#
###############################################################################
ID="Run:4.0.1 -- 19970620";
version="4.0.1"
#######################################################################
# General Purpose Benchmark
# based on the work by Ken McDonell, Computer Science, Monash University
#
#  You will need ...
#	awk cat cc chmod comm cp date dc df echo ed expr
#	kill ls make mkdir rm sed test time touch tty umask who
#       AND /usr/bin/time
#  to generate result indexes, you will also need ...
#       join
#
#  Jon <jon@robots.ox.ac.uk>
# 4/4/92 fixed for GNU time to look like BSD (don't know the format of
# sysV!)
#
# begin jon mods
CC=gcc
export CC
#end Jon mods
umask 022    # at least mortals can read root's files this way
#
if [ -z "${FLAVOR-}" ]; then
	# determine flavor of UNIX from number of lines generated by "time"
	Fcount=`/usr/bin/time date 2>&1 | wc -l | sed 's/ //g'`
	case "$Fcount" in
	2) FLAVOR=BSD ;;
	3) FLAVOR=Linux ;;
	5) FLAVOR=SysV ;;
	*) echo "Flavor of UNIX is not known."
	   echo "Please define FLAVOR in Run script"
	   exit;;
	esac
fi
export FLAVOR
TIME="        %e real        %U user        %S sys"
export TIME

#if SysV use 'uname -a' -- if BSD use 'hostname'
if [ $FLAVOR = "BSD" ]; then
	UNAME="hostname"
else
	UNAME="uname -a"
fi

# check that the required files are in the proper places
if make check; then
        :
else
	make all
fi


# establish full paths to directories
_WD=`pwd`
HOMEDIR=${HOMEDIR-.}
cd $HOMEDIR
HOMEDIR=`pwd`
cd $_WD

BINDIR=${BINDIR-${HOMEDIR}/pgms}
cd $BINDIR
BINDIR=`pwd`
cd $_WD
# let's extend the path to this directory
PATH="${PATH}:${BINDIR}"

SCRPDIR=${SCRPDIR-${HOMEDIR}/pgms}
cd $SCRPDIR
SCRPDIR=`pwd`
cd $_WD

TMPDIR=${HOMEDIR}/tmp
cd $TMPDIR
TMPDIR=`pwd`
cd $_WD

RESULTDIR=${RESULTDIR-${HOMEDIR}/results}
cd $RESULTDIR
RESULTDIR=`pwd`
cd $_WD

TIMEACCUM=${TIMEACCUM-${RESULTDIR}/times}

TESTDIR=${TESTDIR-${HOMEDIR}/testdir}
cd $TESTDIR
TESTDIR=`pwd`
cd $_WD

export BINDIR TMPDIR RESULTDIR PATH TESTDIR TIMEACCUM
#
cat ${BINDIR}/unixbench.logo # display banner
rm -f ${TIMEACCUM}      # clean out old time accumulation file
echo "kill -9 $$" > ${TMPDIR}/kill_run ; chmod u+x ${TMPDIR}/kill_run
#
arithmetic="arithoh short int long float double"
system="execl fstime fsbuffer fsdisk pipe context1 spawn syscall"
misc="C dc hanoi"
dhry="dhry2reg" # dhrystone loops
load="shell" # cummulative load tests
index="double dhry2reg execl fstime fsbuffer fsdisk"
index="$index spawn context1 pipe shell syscall"

args=		# the accumulator for the bench units to be run
runoption=N
# generate list of bench programs
for word
do  # do level 1
	case $word in
	all)
		;;
	arithmetic)
		args="$args $arithmetic"
		;;
	dhry)
		args="$args $dhry"
		;;
	load)
		args="$args $load"
		;;
	misc)
		args="$args $misc"
		;;
	speed)
		args="$args $arithmetic $system"
		;;
	system)
		args="$args $system"
		;;
	index)
		args="$args $index"
		JUSTINDEX=yes
		;;
	-[Qq])
		runoption=Q	#quiet
		shift
		;;
	-[Vv])
		runoption=V	#verbose
		shift
		;;
	-[Dd])
		runoption=D	#debug
		shift
		;;
	-[0-9]*)
		iterations=`echo $word | tr -d '-'`
		shift
		;;
	*)
		args="$args $word"
		;;
	esac
done # end do level 1

#if no benchmark units have be specified, do them all 
# the - option of set implies no options; any list following
# becomes the line arguments (replacing any that may exist)
set - $args
if [ $# -eq 0 ]; then  #no arguments specified
	set - $FULL_SUITE
fi

if [ "$runoption" = 'D' ]; then
	set -x
	set -v
fi

date=`date`
TMPTIMES=${TMPDIR}/$$.tmp
LOGFILE=${RESULTDIR}/log
REPORTLOG=${RESULTDIR}/report
#add old log to accumulated log or move it
if [ -w ${RESULTDIR}/log ]; then
	if [ -w ${RESULTDIR}/log.accum ]; then
		cat ${RESULTDIR}/log >> ${RESULTDIR}/log.accum
		rm ${RESULTDIR}/log
	else
		mv ${RESULTDIR}/log ${RESULTDIR}/log.accum
	fi
fi
echo "|  BYTE UNIX Benchmarks (Version $version)" >>$LOGFILE
echo "|  System --" `$UNAME` >>$LOGFILE
echo "|  Start Benchmark Run: `date`" >>$LOGFILE
echo "|  " `who | wc -l` "interactive users." >>$LOGFILE
echo "|  `uptime`" >> $LOGFILE
echo "|  `ls -l /bin/sh`" >> $LOGFILE
echo "|  `file /bin/sh`" >> $LOGFILE
echo "|  `df -k . | tail -1`" >> $LOGFILE
#if not specified, do each bench 6 iterations
iter=${iterations-10}
# generate list of loop numbers
short=`expr \( $iter + 1 \) / 3`
if [ "$short" -lt 1 ]; then
	short=1
fi
longloop=
shortloop=
while [ $iter -gt 0 ]; do
	# do level 1
	longloop="$iter $longloop"
	if [ "$iter" -le "$short" ]; then
		shortloop="$iter $shortloop"
	fi
	iter=`expr $iter - 1`
done # end do level 1


####################################################################
############## the major control loop ##############################
####################################################################
for bench
do				# line argument processing
	# do level 1
	# set some default values
	prog=${BINDIR}/$bench		# the bench name is default program
	paramlist="#"			# a dummy parameter to make anything run
	testdir=$TESTDIR		# the directory in which to run the test
	prepcmd=			# preparation command or script
	parammsg=
	repeat=$longloop
	stdout="$LOGFILE"
	stdin=
	options=
	logmsg=
	cleanopt="-l $TMPTIMES"
	bgnumber=
	trap "${SCRPDIR}/cleanup.sh -L $LOGFILE -a; exit" 1 2 3 15
	echo >>$LOGFILE
	###################### select the bench specific values ##########
	case $bench in
	dhry2reg)
		options=${dhrytime-10}
		logmsg="Dhrystone 2 using register variables"
		;;

	double)
		options=${arithtime-10}
		logmsg="Arithmetic Test (type = $bench)"
		;;

	syscall)
		options=${systime-10}
		logmsg="System Call Overhead"
		;;

	context1)
		options=${systime-10}
		logmsg="Pipe-based Context Switching"
		;;

	pipe)   
		options=${systime-10}
		logmsg="Pipe Throughput"
		;;

	spawn)  
		options=${systime-30}
		repeat=$shortloop
		logmsg="Process Creation"
		;;

	execl)  
		options=${systime-30}
		repeat=$shortloop
		logmsg="Execl Throughput"
		;;

	fstime) 
		logmsg='Filesystem Throughput 1024 bufsize 2000 maxblocks'
		repeat=$shortloop
		where=${where-${TMPDIR}}
		cleanopt="-f $TMPTIMES"
		options='$param '"$where"
		paramlist=${seconds:-30}
		parammsg='Test Time: $param secs'
		;;

	fsbuffer) 
		logmsg='Filesystem Throughput 256 bufsize 500 maxblocks'
		repeat=$shortloop
		where=${where-${TMPDIR}}
		cleanopt="-f $TMPTIMES"
		options='$param '"$where"
		paramlist=${seconds:-30}
		parammsg='Test Time: $param secs'
		;;

	fsdisk) 
		logmsg='Filesystem Throughput 4096 bufsize 8000 maxblocks'
		repeat=$shortloop
		where=${where-${TMPDIR}}
		cleanopt="-f $TMPTIMES"
		options='$param '"$where"
		paramlist=${seconds:-30}
		parammsg='Test Time: $param secs'
		;;

	shell)
		logmsg='Shell Scripts ($param concurrent)'
		repeat=$shortloop
		prog="looper ${looper-60} multi.sh"
		stdout=/dev/null
		if [ -n "${JUSTINDEX-}" ]; then
			paramlist=${background-"8 "}
		else
			paramlist=${background-"1 8 16 "}
		fi
		parammsg='$param concurrent background processes'
		bgnumber='$param'
		cleanopt="-m $TMPTIMES"
		;;


	##########################
	## Non-Index Benchmarks ##
	##########################

	C)  
		logmsg="C Compiler Throughput"
		repeat=$shortloop
		prog="looper ${looper-60} ${CC} cctest.c"
		stdout=/dev/null
		repeat="$shortloop"
		cleanopt="-m $TMPTIMES"
		rm -f ${TESTDIR}/cctest.o ${TESTDIR}/a.out
		;;

	arithoh)
		logmsg="Arithoh"
		repeat=$shortloop
		options=${arithtime-10}
		;;

	short|int|long|float)
		logmsg="Arithmetic Test (type = $bench)"
		repeat=$shortloop
		options=${arithtime-10}
		;;

	dc)  
		logmsg="Dc: sqrt(2) to 99 decimal places"
		repeat=$shortloop
		prog="looper ${looper-30} dc"
		stdin=dc.dat
		stdout=/dev/null
		cleanopt="-m $TMPTIMES"
		;;

	hanoi)  
		options=${systime-20}
		repeat=$shortloop
		stdout=/dev/null
		logmsg="Recursion Test--Tower of Hanoi"
		parammsg='$param Disk Problem:'
		;;

	*)
		${BINDIR}/cleanup.sh -L $LOGFILE -r \
"run: unknown benchmark \"$bench\" \n Known benchmarks are: \n $FULL_SUITE" -a
		exit 1
		;;
	esac


################################################################
###################### the main task ###########################
###################### run the bench ###########################
################################################################
# each of those variables are now used in a general way
#
    for param in $paramlist
    do   # level 2
      param=`echo $param | sed 's/_/ /g'` # be sure that spaces are used
      eval Lmsg='"'$logmsg'"'
      eval opt='"'$options'"'		 # evaluate any vars in options
      eval prep='"'$prepcmd'"'		 # evaluate any prep command
      eval bg='"'$bgnumber'"'		 # evaluate bgnumber string
      rm -f $TMPTIMES			 # remove any tmp files

      echo "TEST|$Lmsg" >>$TMPTIMES
      echo "FLAVOR|${FLAVOR}" >>$TMPTIMES
      if [ "$runoption" != 'Q' ]
      then
	      echo ""
	      if [ $FLAVOR = "SysV" ]
		 then echo "$Lmsg \c"
		 else echo -n "$Lmsg "
	      fi
	
      fi
      for i in $repeat			 # loop for the specified number
      do  # do depth 3
          if [ "$runoption" != 'D' ]  # level 1
	  then
	    # regular Run - set logfile to go on signal
            trap "${BINDIR}/cleanup.sh -L $LOGFILE -i $i $cleanopt -a; exit" 1 2 3 15
	  else
            trap "exit" 1 2 3 15
	  fi #end level 1
	  # make an attempt to flush buffers
	  sync; sleep 1; sync; sleep 2
	  # display heartbeat
          if [ "$runoption" != Q ]; then
		if [ $FLAVOR = "SysV" ]; then
	        	echo " $i\c"      # display repeat number
		else
			echo -n " $i"
		fi
	  fi
	  pwd=`pwd`                     # remember where we are
	  cd $testdir                   # move to the test directory
	  if [ "${runoption-}" = V ]; then
		echo
		echo "BENCH COMMAND TO BE EXECUTED:"
		echo "$prog $opt"
	  fi

	  # execute any prepratory command string
	  if [ -n "$prep" ]; then
		$prep 2>&1 >>$stdout 
	  fi
	  ############ THE BENCH IS TIMED ##############
          if [ -z "${stdin-}" ]; then
		# without redirected stdin
		/usr/bin/time $prog $opt $bg 2>>$TMPTIMES >>$stdout
          else
		# with redirected stdin
		/usr/bin/time $prog $opt $bg <$stdin 2>>$TMPTIMES >>$stdout
          fi 
#	  /usr/bin/time $benchcmd
# $benchcmd doesn't seem to be defined!? JNT
	  ###############################################
	  cd $pwd                    # move back home
          status=$?                  # save the result code
          if [ $status != 0 ]; then # must have been an error
           if [ -f $TMPTIMES ]; then # is there an error file ?
                cp $TMPTIMES ${TMPDIR}/save.$bench.$param
            ${SCRPDIR}/cleanup.sh -L $LOGFILE -i $i $cleanopt -r \
	       "run: bench=$bench param=$param fatalstatus=$status" -a
           else
            ${SCRPDIR}/cleanup.sh -L $LOGFILE -r \
	       "run: bench=$bench param=$param fatalstatus=$status" -a
           fi 
           exit # leave the script if there are errors
          fi # end  level 1
      done # end do depth 3 - repeat of bench
      if [ "$runoption" != D ]; then
        ${SCRPDIR}/cleanup.sh -L $LOGFILE $cleanopt # finalize this bench
						 # with these options
						 # & calculate results
      fi
    done # end do depth 2 - end of all options for this bench

    ########### some specific cleanup routines ##############
    case $bench in
      C)
      rm -f ${TESTDIR}/cctest.o ${TESTDIR}/a.out
      ;;

      fstime | fsbuffer | fsdisk)
      sync; sleep 1; sync; sleep 1
      ;;
    esac
    if [ "$runoption" != Q ]; then
       echo
    fi
done # end do level 1  - all benchmarks requested
########## a few last items for the end ##############
echo >>$LOGFILE
echo "End Benchmark Run: `date`" >>$LOGFILE
echo " " `who | wc -l` "interactive users." >>$LOGFILE
# create the report
${SCRPDIR}/report.sh $LOGFILE > $REPORTLOG 
${SCRPDIR}/index.sh ${SCRPDIR}/index.base $LOGFILE >> $REPORTLOG
if [ "$runoption" != Q ]; then
	echo
	echo "=============================================================="
	cat $REPORTLOG
fi

exit 0
########################### Amen ######################
